#type vertex
#version 450

layout (std140) uniform CameraUniform
{
    mat4 ViewProj;
    vec3 Position;
    vec3 AimDirection;
} u_Camera;

layout (std140) uniform OrbitUniform
{
    float XOffset;
    float XLimit;
    float YLimit;
    float XEscape;
    float YEscape;
    float SemiMajorAxis;
    float SemiMinorAxis;
    float DrawRadius;
    float XEscapeTangent;
} u_Orbit;

uniform mat4 u_Transform;

layout(location = 0) in vec3 a_Position;

out vec2 v_Position;
out float v_A2;
out float v_B2;

void main()
{
    v_Position = vec2(a_Position.x * u_Orbit.XLimit + u_Orbit.XOffset, a_Position.y * u_Orbit.YLimit);
    v_A2 = pow(u_Orbit.SemiMajorAxis, 2);
    v_B2 = pow(u_Orbit.SemiMinorAxis, 2);

    gl_Position = u_Camera.ViewProj * u_Transform * vec4(a_Position, 1.0);
}


#type fragment
#version 450

layout (std140) uniform OrbitUniform
{
    float XOffset;
    float XLimit;
    float YLimit;
    float XEscape;
    float YEscape;
    float SemiMajorAxis;
    float SemiMinorAxis;
    float DrawRadius;
    float XEscapeTangent;
} u_Orbit;

uniform vec4 u_Color;

in vec2 v_Position;
in float v_A2;
in float v_B2;

layout(location = 0) out vec4 o_Color;

void TestGeneralCase(in float Ey_x, in float Ex_y, out float d)
{
    float A = abs(v_Position.x) - Ey_x;
    float B = abs(v_Position.y) - Ex_y;
    float C = sqrt(pow(A,2) + pow(B,2));

    d = abs(A * B) / C;
}

void TestOutsideMajorAxis(in float Ey_x, out float d)
{
    vec2 absolutePosition = vec2(abs(v_Position.x), abs(v_Position.y));

    if (absolutePosition.y > u_Orbit.SemiMinorAxis)
    {
        d = u_Orbit.DrawRadius;
        return;
    }

    vec2 n = normalize(vec2(absolutePosition.y, u_Orbit.SemiMajorAxis - Ey_x));
    vec2 Ex = vec2(u_Orbit.SemiMajorAxis, 0);

    d = abs(dot(absolutePosition, n) - dot(Ex, n));
}

void TestOutsideMinorAxis(in float Ex_y, out float d)
{
    vec2 absolutePosition = vec2(abs(v_Position.x), abs(v_Position.y));

    if (absolutePosition.x > u_Orbit.SemiMajorAxis)
    {
        d = u_Orbit.DrawRadius;
        return;
    }

    vec2 n = normalize(vec2(u_Orbit.SemiMinorAxis - Ex_y, absolutePosition.x));
    vec2 Ey = vec2(0, u_Orbit.SemiMinorAxis);

    d = abs(dot(absolutePosition, n) - dot(Ey, n));
}

void main()
{
    float Ey_x = sqrt(v_A2 * (1.0 - pow(v_Position.y, 2) / v_B2));
    float Ex_y = sqrt(v_B2 * (1.0 - pow(v_Position.x, 2) / v_A2));

    vec2 positionRelativeEscape = vec2(v_Position.x - u_Orbit.XEscape, abs(v_Position.y) - u_Orbit.YEscape);
    float yEscapeTangent = 1;
    if (u_Orbit.XEscape < 0)
    {
        yEscapeTangent = -1;
    }
    vec2 escapeTangent = vec2(u_Orbit.XEscapeTangent, yEscapeTangent);

    float d = 1.0;
    if (u_Orbit.YEscape > 0 && dot(positionRelativeEscape, escapeTangent) > 0)
    {
        // No drawing beyond the escape point
    }
    else if (abs(v_Position.x) > u_Orbit.SemiMajorAxis)
    {
        TestOutsideMajorAxis(Ey_x, d);
    }
    else if (abs(v_Position.y) > u_Orbit.SemiMinorAxis)
    {
        TestOutsideMinorAxis(Ex_y, d);
    }
    else
    {
        TestGeneralCase(Ey_x, Ex_y, d);
    }

    float dF = ceil(u_Orbit.DrawRadius - d);

    vec4 color = dF * u_Color;
    o_Color = vec4(color.rgb * color.a, color.a); // Premultiplied alpha
}
